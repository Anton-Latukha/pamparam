* Clojure functions                                                                      :cards:
https://clojuredocs.org/clojure.core/
** Number of items in the collection
#+begin_src clojure
(count nil)
;; => 0

(count [])
;; => 0

(count [1 2 3])
;; => 3

(count {:one 1 :two 2})
;; => 2

(count [1 \a "string" [1 2] {:foo :bar}])
;; => 5

(count "string")
;; => 6
#+end_src
*** a
count
** Create a new vector from collection
#+begin_src clojure
(vec '(1 2 3))
;; => [1 2 3]

(vec [1 2 3])
;; => [1 2 3]

(vec #{1 2 3})
;; => [1 3 2]

(vec {:a 1 :b 2 :c 3})
;; => [[:a 1] [:b 2] [:c 3]]

(vec '())
;; => []
#+end_src
*** a
vec
** Repeat an object several times
#+begin_src clojure
(repeat 5 \A)
;; => (\A \A \A \A \A)
#+end_src
*** a
repeat
** Return a new set of the same type without keys
#+begin_src clojure
(disj #{1 2 3} 2)
;; => #{1 3}

(disj #{1 2 3} 1 3)
;; => #{2}
#+end_src
*** a
disj
** Return the value in a nested map, using a sequence of keys
#+begin_src clojure
;;* Reach into nested maps
(def m {:username "sally"
        :profile {:name "Sally Clojurian"
                  :address {:city "Austin" :state "TX"}}})

;;** :
(get-in m [:profile :name])
;; => "Sally Clojurian"

;;** :
(get-in m [:profile :address :city])
;; => "Austin"

;;** :
(get-in m [:profile :address :zip-code])
;; => nil

;;** :
(get-in m [:profile :address :zip-code] "no zip code!")
;; => "no zip code!"

;;* Vectors are also associative
(def v [[1 2 3]
        [4 5 6]
        [7 8 9]])

;;** :
(get-in v [0 2])
;; => 3

;;** :
(get-in v [2 1])
;; => 8

;;* Mix associative types:
(def mv {:username "jimmy"
         :pets [{:name "Rex"
                 :type :dog}
                {:name "Sniffles"
                 :type :hamster}]})
(get-in mv [:pets 1 :type])
;; => :hamster
#+end_src
*** a
get-in
